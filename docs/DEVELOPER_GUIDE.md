# üìñ Developer Guide - Playwright Automation Framework

**Version:** 1.0  
**Last Updated:** February 26, 2026  
**Consolidates:** File Generation Templates ¬∑ Step Definition Best Practices ¬∑ Smart Element Handler ¬∑ NPM Migration Guide

---

## üìã Table of Contents

1. [Part 1: File Generation Standards](#-part-1-file-generation-standards)
2. [Part 2: Step Definition Best Practices](#-part-2-step-definition-best-practices)
3. [Part 3: Smart Element Handler Reference](#-part-3-smart-element-handler-reference)
4. [Part 4: NPM CLI & Migration Guide](#-part-4-npm-cli--migration-guide)

---

---

# üìÑ Part 1: File Generation Standards

> **Purpose:** Ensure ALL generated files have minimum executable content ‚Äî no empty files!

---

## üö´ CRITICAL RULE: NO EMPTY FILES

**‚ö†Ô∏è All generated files MUST be immediately compilable and executable!**

Every file generated from prompts MUST contain:

- ‚úÖ Proper package/namespace declarations
- ‚úÖ Required imports
- ‚úÖ Actual implementations (not just signatures/placeholders)
- ‚úÖ Minimum line count thresholds
- ‚úÖ Compilable code (mvn compile must pass)

---

## üìä Minimum Requirements by File Type

### Page Object Files (.java)

**Minimum:** 50 lines  
**MUST HAVE:**

- `package pages;` declaration
- All required imports (Playwright, BasePage, TimeoutConfig, Logger)
- Class extending BasePage with JavaDoc
- Constructor calling `super()`
- At least 1 element locator method (`private Locator getXXX()`)
- At least 1 action method (`public void performXXX()`)
- Logger instance
- navigateTo() method implemented

**REJECT IF:**

- Only package + class declaration (< 30 lines)
- No action methods (just locators)
- Empty class body
- Missing required imports
- No constructor

### Feature Files (.feature)

**Minimum:** 15 lines  
**MUST HAVE:**

- `Feature:` declaration with description
- At least 1 complete `Scenario` (use `Scenario Outline` only when there are 2+ data rows)
- At least 3 steps (Given, When, Then)
- @Tag annotations (feature name + story ID)
- Examples table (for Scenario Outline only)

**REJECT IF:**

- Only Feature: declaration (< 10 lines)
- No scenarios defined
- No steps in scenario
- Missing Given/When/Then structure
- `Scenario Outline` with a single data row (use plain `Scenario` instead)

### Step Definition Files (.java)

**Minimum:** 60 lines  
**MUST HAVE:**

- `package stepDefs;` declaration
- All required imports (Cucumber annotations, Page objects)
- JavaDoc comment
- At least 3 step methods (@Given, @When, @Then)
- Page object instantiation
- Actual implementation code (not just TODO comments)
- Logger instance

**REJECT IF:**

- Only package + imports (< 40 lines)
- Only method signatures without implementation
- All methods throw `new PendingException()`
- No page object usage

### Configuration Files (.properties)

**Minimum:** 10 key-value pairs  
**MUST HAVE:**

- Header comment explaining purpose
- At least 5 key-value pairs
- Environment-specific values
- Proper format (key=value)
- No empty values for required keys

**REJECT IF:**

- Only comments, no properties
- All values are empty or placeholder text
- Invalid format

---

## üéØ Standard Templates

### 1. Page Object Template

```java
package pages;

import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.AriaRole;
import configs.loadProps;
import configs.TimeoutConfig;
import java.util.logging.Logger;

/**
 * [PageName] Page Object
 * Generated by Playwright Automation Framework
 *
 * @author Auto-Generated
 * @version 1.0
 */
public class [PageName] extends BasePage {
    private static final Logger log = Logger.getLogger([PageName].class.getName());

    /**
     * Constructor
     */
    public [PageName]() {
        super();
    }

    // ============================================================
    // LOCATORS
    // ============================================================

    private Locator get[Element]Button() {
        return page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("[ElementName]"));
    }

    private Locator get[Field]Input() {
        return page.getByPlaceholder("[Placeholder text]");
    }

    // ============================================================
    // ACTIONS
    // ============================================================

    public void navigateTo() {
        log.info("üåê Navigating to [PageName] page");
        navigateToUrl(loadProps.getProperty("baseUrl") + "/[path]");
        TimeoutConfig.waitForPageLoad();
        log.info("‚úÖ [PageName] page loaded successfully");
    }

    public void perform[Action]() {
        log.info("üîò Performing [action]");
        clickOnElement(get[Element]Button());
        TimeoutConfig.waitShort();
        log.info("‚úÖ [Action] completed");
    }

    public void enter[Field](String value) {
        log.info("üìù Entering value in [field]: " + value);
        enterText(get[Field]Input(), value);
        log.info("‚úÖ Value entered successfully");
    }

    // ============================================================
    // VERIFICATIONS
    // ============================================================

    public boolean verify[Element]Visible() {
        log.info("üîç Verifying [element] visibility");
        boolean isVisible = isElementPresent(get[Element]Button());
        log.info(isVisible ? "‚úÖ [Element] is visible" : "‚ùå [Element] not visible");
        return isVisible;
    }
}
```

---

### 2. Feature File Template

```gherkin
@[StoryID] @[FeatureName]
Feature: [Feature Name] Test
  As a user
  I want to test [feature description]
  So that I can ensure [business value]

  Background:
    Given the application is ready
    And user is on the application home page

  @Smoke @Regression
  Scenario: Successful [action]
    Given user navigates to [page name] page
    When user performs [action]
    And user enters "[value]" in [field]
    Then user should see [expected result]
    And [verification step]

  @Negative
  Scenario: [Negative test case]
    Given user navigates to [page name] page
    When user performs [invalid action]
    Then user should see error message "[error message]"

  @DataDriven
  Scenario Outline: [Feature] with multiple datasets
    Given user navigates to [page name] page
    When user enters "<username>" and "<password>"
    Then login should be "<result>"

    Examples:
      | username     | password  | result  |
      | validUser    | validPass | success |
      | invalidUser  | wrongPass | failure |
      | emptyUser    |           | failure |
```

---

### 3. Step Definitions Template

```java
package stepDefs;

import configs.base;
import configs.browserSelector;
import configs.loadProps;
import io.cucumber.java.en.*;
import pages.[PageName];
import java.util.logging.Logger;

/**
 * Step Definitions for [Feature Name]
 * Auto-generated from Playwright recording
 *
 * @author Auto-Generated
 * @version 1.0
 */
public class [Feature]Steps extends base {
    private static final Logger log = Logger.getLogger([Feature]Steps.class.getName());
    private [PageName] [pageName]Page;

    public [Feature]Steps() {
        this.[pageName]Page = new [PageName]();
    }

    @Given("user navigates to [page name] page")
    public void userNavigatesToPage() {
        log.info("üìç Step: Navigating to [page name] page");
        [pageName]Page.navigateTo();
    }

    @When("user performs [action]")
    public void userPerformsAction() {
        log.info("üìç Step: Performing [action]");
        [pageName]Page.perform[Action]();
    }

    @When("user enters {string} in [field]")
    public void userEntersValue(String value) {
        log.info("üìç Step: Entering value: " + value);
        [pageName]Page.enter[Field](value);
    }

    @Then("user should see [expected result]")
    public void userShouldSeeResult() {
        log.info("üìç Step: Verifying expected result");
        // BEST PRACTICE: Always use .first().isVisible() ‚Äî never use count() > 0 for
        // single element checks. count() > 0 is ~10x slower and does not verify visibility.
        // ‚úÖ CORRECT:  element.first().isVisible()
        // ‚ùå WRONG:    element.count() > 0
        boolean isVisible = [pageName]Page.verify[Element]Visible();
        if (!isVisible) {
            throw new AssertionError("‚ùå Expected result not visible");
        }
        log.info("‚úÖ Verification passed");
    }

    @And("[verification step]")
    public void verificationStep() {
        log.info("üìç Step: Additional verification");
        boolean isValid = [pageName]Page.verify[AdditionalElement]Visible();
        if (!isValid) {
            throw new AssertionError("‚ùå Verification failed");
        }
    }
}
```

---

### 4. Configuration File Template

```properties
# ============================================================
# Application Configuration
# Generated by Playwright Automation Framework
# Generated on: [Date]
# ============================================================

environment=qa
baseUrl=https://qa.example.com
timeout=30000
pageLoadTimeout=60000

browser=chromium
headless=false
slowMo=0
viewport.width=1920
viewport.height=1080

maxRetryCount=2
screenshotOnFailure=true
videoRecording=true
traceOnFailure=true
parallelExecution=true
threadCount=4

reportPath=target/cucumber-reports
extentReportPath=target/extent-reports
sparkReportPath=target/spark-reports
jsonReportPath=target/json-report

logLevel=INFO
logToFile=true
logPath=test-health-logs
detailedLogging=false

testDataPath=src/test/resources/test-data
configFilePath=src/test/resources/configurations.properties
```

---

### 5. Test Runner Template

```java
package runner;

import io.cucumber.testng.AbstractTestNGCucumberTests;
import io.cucumber.testng.CucumberOptions;
import org.testng.annotations.DataProvider;

@CucumberOptions(
    features = "src/test/java/features",
    glue = {"stepDefs", "hooks"},
    tags = "@Regression or @Smoke",
    plugin = {
        "pretty",
        "html:target/cucumber-reports/cucumber.html",
        "json:target/json-report/cucumber.json",
        "com.aventstack.extentreports.cucumber.adapter.ExtentCucumberAdapter:",
        "rerun:target/rerun.txt"
    },
    monochrome = true,
    dryRun = false,
    publish = false
)
public class TestRunner extends AbstractTestNGCucumberTests {

    @Override
    @DataProvider(parallel = true)
    public Object[][] scenarios() {
        return super.scenarios();
    }
}
```

---

## ‚úÖ Validation Rules & Enforcement

### Pre-Generation Checks

```
1. Input Validation:
   ‚úì Recording has >= 3 actions
   ‚úì JIRA story has >= 1 acceptance criterion
   ‚úì Feature name is valid Java identifier
   ‚úì All required fields populated

2. If Insufficient Input:
   ‚Üí Recording < 3 actions: Generate 5 common actions
   ‚Üí JIRA no ACs: Generate 3 generic CRUD scenarios
   ‚Üí Page no elements: Generate common elements
   ‚Üí Steps undefined: Generate implementations calling page methods
```

### Post-Generation Validation

```
1. Line Count Validation:
   ‚úì Page Object >= 50 lines
   ‚úì Feature File >= 15 lines
   ‚úì Step Definitions >= 60 lines
   ‚úì Configuration >= 10 properties

2. Keyword Validation:
   ‚úì Page Object contains: "extends BasePage", "public void", "private Locator"
   ‚úì Feature contains: "Feature:", "Scenario:", "Given", "When", "Then"
   ‚úì Steps contain: "@Given", "@When", "@Then", "public void"

3. Compilation Validation:
   ‚úì Run: mvn compile -DskipTests
   ‚úì Exit code = 0 (success)
   ‚úì No compilation errors

4. Implementation Validation:
   ‚úì No placeholder comments left: [TODO], [FIXME] without code
   ‚úì All methods have body (not just signatures)
   ‚úì Imports are used (no unused imports)
   ‚úì Variables declared are used
```

### Enforcement in Code

```java
// TestGeneratorHelper.java
if (nonLoginStepsGenerated == 0 && !hasGeneratedLoginSteps) {
    throw new IOException("Feature generation incomplete: Not all recorded actions were captured.");
}
```

```javascript
// automation-cli.js
function validateAndFixPageObject(code, className) {
    // Ensures minimum structure, required imports, logger, constructor, at least 1 method
}
```

---

## üìä Content Quality Metrics

| File Type | Min Lines | Min Methods | Must Extend | Must Compile |
|-----------|-----------|-------------|-------------|--------------|
| **Page Object** | 50 | 3 | BasePage | ‚úÖ Yes |
| **Feature File** | 15 | N/A (3 steps) | N/A | ‚úÖ Yes (Gherkin) |
| **Step Definitions** | 60 | 3 steps | base | ‚úÖ Yes |
| **Configuration** | 10 props | N/A | N/A | ‚úÖ Yes |
| **Test Runner** | 40 | 1 | AbstractTestNGCucumberTests | ‚úÖ Yes |

### Quality Gates

```
‚úÖ PASS: all files >= minimum line count ¬∑ mvn compile SUCCESS ¬∑ no empty methods
         no [TODO]/[FIXME] without implementation ¬∑ Logger initialized ¬∑ page objects extend BasePage

‚ùå FAIL (auto-regenerate): any file < minimum line count ¬∑ compilation errors
                            empty class/scenario bodies ¬∑ missing required imports
```

---

## üìù File Generation Checklist

Before writing ANY file to disk:

- [ ] Used appropriate template from this document
- [ ] Replaced all [placeholders] with actual values
- [ ] Met minimum line count for file type
- [ ] Added all required imports
- [ ] Included Logger initialization
- [ ] All methods have implementations (not just signatures)
- [ ] No [TODO] comments without code
- [ ] Validated compilation would succeed
- [ ] Added JavaDoc for public methods
- [ ] Used framework conventions (naming, structure)

---

---

# üéØ Part 2: Step Definition Best Practices

> **Purpose:** Prevent common issues in generated step definitions ‚Äî permanent fixes and prevention guide.

---

## üö´ CRITICAL ISSUES TO AVOID

### 1. NO `:has-text()` Pseudo-Selector in Java

**‚ùå WRONG (Causes compilation errors):**

```java
Locator element = page.locator("button:has-text('Submit')");
Locator error = page.locator("*:has-text('Error message')");
Locator element = page.locator("*:visible:has-text('Text')");
```

**‚úÖ CORRECT (Use `.filter()` method instead):**

```java
// For buttons with text
Locator submitBtn = page.locator("button")
    .filter(new Locator.FilterOptions().setHasText("Submit"));

// For any element with text
Locator error = page.locator(".error, .alert-danger, [role='alert']")
    .or(page.locator("*").filter(new Locator.FilterOptions().setHasText("Error message")));

// Multiple locators with fallback
Locator element = page.locator(".success, [class*='success']")
    .or(page.locator("*").filter(new Locator.FilterOptions().setHasText("Success")));
```

---

### 2. Proper String Escaping in Selectors

**‚ùå WRONG (Quote escaping issues):**

```java
String id = "username";
page.locator("label[for=\"" + id + "\"]");  // Compilation error!
```

**‚úÖ CORRECT (Use single quotes inside selector strings):**

```java
// Method 1: Use single quotes
String labelSelector = "label[for='" + id + "']";
page.locator(labelSelector);

// Method 2: String formatting
String selector = String.format("label[for='%s']", id);
page.locator(selector);
```

---

### 3. Smart Error Validation Patterns

**‚ùå WRONG (Too generic, unreliable):**

```java
Locator error = page.locator(".error");
Assert.assertTrue(error.count() > 0, "Error should be displayed");
```

**‚úÖ CORRECT (Comprehensive, multiple selectors):**

```java
Locator error = page.locator(
    ".error, .alert-danger, [role='alert'], " +
    "[class*='error'], .invalid-feedback, [class*='invalid']"
).first();

Assert.assertTrue(error.isVisible(), "Expected validation error to be displayed");
```

---

### 4. Never Use `count() > 0` for Single-Element Visibility

**‚ùå WRONG (`count() > 0` is ~10x slower and doesn't check visibility):**

```java
Assert.assertTrue(element.count() > 0, "Element should be visible");   // BAD
if (element.count() > 0) { element.first().click(); }                   // BAD
```

**‚úÖ CORRECT (Use `.first().isVisible()`):**

```java
Assert.assertTrue(element.first().isVisible(), "Element should be visible");  // FAST
if (element.first().isVisible()) { element.first().click(); }                 // FAST
```

**Exception:** Use `count() > 0` only inside loops for existence checks where `isVisible()` would auto-wait the full timeout on every missing element (e.g., checking labels for multiple inputs).

---

### 5. Avoid Duplicate Step Definitions

**PERMANENT RULE:** Always check if a step already exists before generating.

**Common Steps (Use existing from LoginSteps.java):**

- Login/Logout actions ‚Üí Use `@When("user clicks on logout")` from LoginSteps
- Authentication ‚Üí Use existing login methods
- Navigation ‚Üí Use existing navigation steps

**‚úÖ Before generating, check:**

```java
// Search all existing *Steps.java files for:
@When("user clicks on logout")
@Then("page should be updated")
// If found, REUSE instead of creating new step definition
```

---

### 6. Smart Locator Priority (ID First Strategy)

**PRIORITY ORDER:**

1. ‚úÖ **ID Attribute** (Highest priority, most stable)

   ```java
   page.locator("#username")
   ```

2. ‚úÖ **Name Attribute**

   ```java
   page.locator("input[name='username']")
   ```

3. ‚úÖ **Data-testid / Accessibility Attributes**

   ```java
   page.locator("[data-testid='submit-button']")
   page.locator("[aria-label='Username']")
   ```

4. ‚ö†Ô∏è **Label Text** (Use as fallback)

   ```java
   page.getByLabel("Username")
   ```

5. ‚ùå **Avoid:** Generic selectors, XPath with indices

   ```java
   page.locator("input")                // BAD ‚Äî too generic
   page.locator("//div[1]/input[2]")    // BAD ‚Äî fragile
   ```

---

### 7. Tab Key Simulation

**‚ùå WRONG (Trying to click "Tab key"):**

```java
Locator element = page.locator("*:has-text('Tab key')");  // Nonsensical
element.click();
```

**‚úÖ CORRECT (Use keyboard press):**

```java
@Then("User presses Tab key")
public void userPressesTabKey() {
    page.keyboard().press("Tab");
    TimeoutConfig.waitShort();
}
```

---

### 8. Success/Error Message Validation Template

```java
@Then("Success feedback should be provided")
public void successFeedbackShouldBeProvided() {
    Locator success = page.locator(".success, [class*='success']")
        .or(page.locator("*").filter(new Locator.FilterOptions().setHasText("Success")));

    Assert.assertTrue(
        success.first().isVisible() ||
        page.url().contains("success") ||
        page.url().contains("dashboard"),
        "Expected success state after action"
    );
}

@Then("Validation error should be displayed")
public void validationError() {
    Locator error = page.locator(
        ".error, .alert-danger, [role='alert'], " +
        "[class*='error'], .invalid-feedback, [class*='invalid']"
    ).first();
    Assert.assertTrue(error.isVisible(), "Expected validation error to be displayed");
}
```

---

## üéØ Handling Multiple Elements With the Same Name

### Problem

Pages often have multiple buttons with the same text (e.g., multiple "Add" buttons in different sections). Naive selectors click the wrong one or throw ambiguity errors.

---

### Strategy 1: Context/Section Identifiers ‚≠ê RECOMMENDED

Scope the locator to a specific section/container:

```java
@When("user clicks Add button in Users section")
public void clickAddButtonInUsersSection() {
    Locator usersSection = page.locator("#users-section, [data-section='users']");
    Locator addButton = usersSection.locator("button")
        .filter(new Locator.FilterOptions().setHasText("Add"));
    addButton.click();
}

@When("user clicks Delete button for user {string}")
public void clickDeleteButtonForUser(String userName) {
    Locator userRow = page.locator("tr")
        .filter(new Locator.FilterOptions().setHasText(userName));
    userRow.locator("button")
        .filter(new Locator.FilterOptions().setHasText("Delete"))
        .click();
}
```

---

### Strategy 2: Unique Attributes ‚≠ê BEST FOR TEST AUTOMATION

```java
page.locator("[data-testid='add-user-btn']").click();
page.locator("#header-save-btn").click();
page.locator("button[name='save-primary']").click();
```

**Recommendation for devs:**

```html
<!-- ‚úÖ GOOD -->
<button data-testid="add-user-btn">Add</button>
<button data-testid="add-product-btn">Add</button>
<!-- ‚ùå BAD ‚Äî indistinguishable -->
<button>Add</button>
<button>Add</button>
```

---

### Strategy 3: Accessible ARIA Attributes ‚≠ê

```java
page.locator("button[aria-label='Add User']").click();
page.locator("button[aria-label='Add Product']").click();
```

---

### Strategy 4: Position/Index ‚ö†Ô∏è FALLBACK ONLY

```java
// ‚ö†Ô∏è Only when order is guaranteed stable
Locator addButtons = page.locator("button")
    .filter(new Locator.FilterOptions().setHasText("Add"));
if (addButtons.count() >= 2) {
    addButtons.nth(1).click();
} else {
    Assert.fail("Expected at least 2 Add buttons, found: " + addButtons.count());
}

// ‚ùå BAD ‚Äî no context, no validation
page.locator("button").nth(5).click();
```

---

### Multiple Elements Decision Tree

```
Multiple elements with same name?
‚îÇ
‚îú‚îÄ‚Üí Different sections/containers? ‚Üí Use context locator (Strategy 1) ‚≠ê
‚îú‚îÄ‚Üí Have data-testid or unique IDs? ‚Üí Use unique attributes (Strategy 2) ‚≠ê
‚îú‚îÄ‚Üí Different aria-labels? ‚Üí Use ARIA (Strategy 3) ‚≠ê
‚îú‚îÄ‚Üí Position predictable & stable? ‚Üí Use index with validation (Strategy 4) ‚ö†Ô∏è
‚îî‚îÄ‚Üí None of the above? ‚Üí Ask devs to add unique identifiers
```

---

## üìã Code Generation Checklist

### Before Generating Step Definitions

- [ ] Check for existing common steps (login, logout, navigation)
- [ ] Verify no duplicate method names across all `*Steps.java` files
- [ ] Ensure locators use ID first, then name, then aria-label
- [ ] Validate all selectors are Playwright Java compatible
- [ ] No `:has-text()` in CSS strings
- [ ] Single quotes used inside selector strings
- [ ] Use `.filter()` for text-based element finding
- [ ] Add comprehensive error messages to assertions

### After Generating Step Definitions

- [ ] Run `mvn clean compile` to verify no errors
- [ ] Check for duplicate step definition warnings
- [ ] Verify all imports resolve correctly
- [ ] Test execution with a sample feature file
- [ ] Review generated locators for stability
- [ ] Ensure no placeholder TODOs remain

---

## üîß Automated Fix Patterns

| Input Pattern (Wrong) | Auto-Convert To (Correct) |
|---|---|
| `"button:has-text('Text')"` | `page.locator("button").filter(new Locator.FilterOptions().setHasText("Text"))` |
| `"label[for=\"" + id + "\"]"` | `"label[for='" + id + "']"` |
| `page.locator(".error")` | `page.locator(".error, .alert-danger, [role='alert'], [class*='error']")` |
| `element.count() > 0` | `element.first().isVisible()` |

---

## üìä Quality Metrics

Generated code MUST pass:

1. ‚úÖ **Compilation** ‚Äî Zero errors with `mvn clean compile`
2. ‚úÖ **No Duplicates** ‚Äî Zero duplicate step definition warnings
3. ‚úÖ **Selector Validity** ‚Äî All Playwright Java compatible
4. ‚úÖ **Best Practices** ‚Äî `.first().isVisible()` not `count() > 0`
5. ‚úÖ **Assertion Messages** ‚Äî All assertions have descriptive messages
6. ‚úÖ **Logging** ‚Äî Important steps logged

### Code Review Red Flags

- üö´ Any `:has-text()` in selector strings
- üö´ Double quotes inside double-quoted strings
- üö´ Generic selectors like `page.locator("button")`
- üö´ `count() > 0` for single element visibility
- üö´ Assertions without messages
- üö´ Duplicate step definition methods

---

## üí° Templates for Common Patterns

### Click Action Step

```java
@When("user clicks on {element}")
public void clickElement() {
    System.out.println("üìç Step: User clicks on {element}");
    Locator element = page.locator("#elementId")
        .or(page.locator("[name='elementName']"))
        .or(page.locator("button").filter(new Locator.FilterOptions().setHasText("{Element}")));
    element.first().click();
    TimeoutConfig.waitShort();
}
```

### Text Input Step

```java
@When("user enters {string} in {field}")
public void enterText(String value) {
    System.out.println("üìç Step: Entering text: " + value);
    Locator field = page.locator("#fieldId")
        .or(page.locator("input[name='fieldName']"))
        .or(page.getByLabel("{Field}"));
    field.first().fill(value);
    TimeoutConfig.waitShort();
}
```

### Validation Step

```java
@Then("{element} should be visible")
public void verifyElementVisible() {
    System.out.println("üìç Step: Verifying {element} is visible");
    Locator element = page.locator("#elementId")
        .or(page.locator("[aria-label='{Element}']"));
    Assert.assertTrue(element.first().isVisible(), "{Element} should be visible");
}
```

### Error Message Validation

```java
@Then("error message should be displayed")
public void verifyErrorMessage() {
    System.out.println("üìç Step: Verifying error message");
    Locator error = page.locator(
        ".error, .alert-danger, [role='alert'], " +
        "[class*='error'], .invalid-feedback, [class*='invalid']"
    ).first();
    Assert.assertTrue(error.isVisible(), "Expected error message to be displayed");
}
```

---

---

# üéØ Part 3: Smart Element Handler Reference

> **Purpose:** Handle multiple elements with the same name/text intelligently using `SmartElementHandler`.

---

## üìã Problem Statement

Pages often have multiple buttons with the same text:

- Multiple "Add" buttons (Add User, Add Product, Add Item)
- Multiple "Save" buttons (header, footer)
- Multiple "Delete" buttons (one per table row)

**Old Way (Problematic):**

```java
// ‚ùå Which Add button? Fragile if order changes
page.locator("button").filter(new Locator.FilterOptions().setHasText("Add")).click();
page.locator("button").nth(2).click();
```

**New Way (SmartElementHandler):**

```java
// ‚úÖ Clear, specific, robust
SmartElementHandler.clickButtonInContext(page, "Add", "#users-section");
SmartElementHandler.clickButtonSmart(page, "add-user-btn", "Add User");
```

---

## üöÄ Quick Start

```java
import configs.SmartElementHandler;

@When("User clicks Add button")
public void clickAddButton() {
    SmartElementHandler.clickFirstVisibleButton(page, "Add");
}
```

---

## üìö Available Methods

### `clickButtonInContext()` ‚≠ê MOST RECOMMENDED

**When to use:** Multiple buttons in different sections/containers

```java
SmartElementHandler.clickButtonInContext(page, "Add", "#users-section");
SmartElementHandler.clickButtonInContext(page, "Save", "form[name='userForm']");
SmartElementHandler.clickButtonInContext(page, "Delete", ".settings-panel");
```

---

### `clickButtonSmart()` ‚≠ê PRODUCTION READY

**Priority order:** ID ‚Üí data-testid ‚Üí name ‚Üí aria-label ‚Üí text content

```java
SmartElementHandler.clickButtonSmart(page, "add-user-btn", "Add User");
SmartElementHandler.clickButtonSmart(page, "save-primary", "Save");
SmartElementHandler.clickButtonSmart(page, "submit-form", "Submit");
```

---

### `clickNthButton()` ‚ö†Ô∏è USE WITH CAUTION

**When to use:** Elements in predictable, stable order only

```java
SmartElementHandler.clickNthButton(page, "Add", 0);   // first
SmartElementHandler.clickNthButton(page, "Save", 1);  // second
```

---

### `clickFirstVisibleButton()` ‚≠ê RECOMMENDED

**When to use:** Multiple buttons exist but only one is visible at a time

```java
SmartElementHandler.clickFirstVisibleButton(page, "Add");
SmartElementHandler.clickFirstVisibleButton(page, "Submit");
```

---

### `getButtonCount()` ‚Äî Validation

```java
int count = SmartElementHandler.getButtonCount(page, "Add");
Assert.assertTrue(count > 0, "At least one Add button should exist");
Assert.assertEquals(SmartElementHandler.getButtonCount(page, "Delete"), 5,
    "Should have 5 Delete buttons (one per row)");
```

---

### `clickButtonInRow()` ‚≠ê TABLES/LISTS

**When to use:** Action buttons in data tables

```java
SmartElementHandler.clickButtonInRow(page, "John Doe", "Edit");
SmartElementHandler.clickButtonInRow(page, "Product-12345", "Delete");
SmartElementHandler.clickButtonInRow(page, "INV-2024-001", "Approve");
```

---

### `clickButtonNearElement()` ‚≠ê ADJACENT ELEMENTS

```java
SmartElementHandler.clickButtonNearElement(page, "#username", "Clear");
SmartElementHandler.clickButtonNearElement(page, "input[name='email']", "Verify");
SmartElementHandler.clickButtonNearElement(page, "input[type='file']", "Browse");
```

---

### `validateButtonState()` ‚Äî Pre-condition checks

```java
SmartElementHandler.validateButtonState(page, "Submit", true);   // must exist
SmartElementHandler.validateButtonState(page, "Delete", false);  // must NOT exist
```

---

### `clickButtonWithRetry()` ‚≠ê FLAKY ELEMENTS

**When to use:** Button may take time to become clickable (AJAX, slow backend)

```java
SmartElementHandler.clickButtonWithRetry(page, "Submit", 3);
SmartElementHandler.clickButtonWithRetry(page, "Process", 5);
```

---

## üéØ Method Selection Decision Tree

```
Need to click a button?
‚îÇ
‚îú‚îÄ‚Üí Button in specific section/container? ‚Üí clickButtonInContext() ‚≠ê
‚îú‚îÄ‚Üí Button has unique ID or data-testid? ‚Üí clickButtonSmart() ‚≠ê
‚îú‚îÄ‚Üí Button in table row? ‚Üí clickButtonInRow() ‚≠ê
‚îú‚îÄ‚Üí Only one button visible at a time? ‚Üí clickFirstVisibleButton() ‚≠ê
‚îú‚îÄ‚Üí Button near specific element? ‚Üí clickButtonNearElement() ‚≠ê
‚îú‚îÄ‚Üí Button position is stable? ‚Üí clickNthButton() ‚ö†Ô∏è
‚îî‚îÄ‚Üí Button may be slow to load? ‚Üí clickButtonWithRetry() ‚≠ê
```

---

## üí° Real-World Examples

### User Management Page

```java
@When("User adds a new user")
public void addNewUser() {
    SmartElementHandler.clickButtonInContext(page, "Add", "#users-section");
}

@When("User edits user {string}")
public void editUser(String userName) {
    SmartElementHandler.clickButtonInRow(page, userName, "Edit");
}

@When("User deletes user {string}")
public void deleteUser(String userName) {
    SmartElementHandler.clickButtonInRow(page, userName, "Delete");
    SmartElementHandler.clickButtonSmart(page, "confirm-delete", "Confirm");
}
```

### Form with Multiple Sections

```java
@When("User saves personal info")
public void savePersonalInfo() {
    SmartElementHandler.clickButtonInContext(page, "Save", "#personal-info-section");
}

@When("User saves address info")
public void saveAddressInfo() {
    SmartElementHandler.clickButtonInContext(page, "Save", "#address-section");
}

@When("User submits entire form")
public void submitForm() {
    SmartElementHandler.clickButtonWithRetry(page, "Submit", 3);
}
```

---

## üîß SmartElementHandler Utility Class Implementation

```java
public class SmartElementHandler {

    /** Click button by text within a specific context/section */
    public static void clickButtonInContext(Page page, String buttonText, String contextSelector) {
        Locator context = page.locator(contextSelector);
        if (!context.isVisible()) {
            Assert.fail("Context not found: " + contextSelector);
        }
        Locator button = context.locator("button, [role='button']")
            .filter(new Locator.FilterOptions().setHasText(buttonText));
        int count = button.count();
        if (count == 0) {
            Assert.fail("No '" + buttonText + "' button found in context: " + contextSelector);
        }
        System.out.println("üìä Found " + count + " '" + buttonText + "' button(s) in context");
        button.first().click();
        System.out.println("‚úÖ Clicked '" + buttonText + "' button");
    }

    /** Click button by priority: ID > data-testid > aria-label > text */
    public static void clickButtonSmart(Page page, String buttonId, String buttonText) {
        Locator button;
        String method;
        if (page.locator("#" + buttonId).count() > 0) {
            button = page.locator("#" + buttonId); method = "ID";
        } else if (page.locator("[data-testid='" + buttonId + "']").count() > 0) {
            button = page.locator("[data-testid='" + buttonId + "']"); method = "data-testid";
        } else if (page.locator("[aria-label='" + buttonText + "']").count() > 0) {
            button = page.locator("[aria-label='" + buttonText + "']"); method = "aria-label";
        } else {
            button = page.locator("button, [role='button']")
                .filter(new Locator.FilterOptions().setHasText(buttonText));
            method = "text";
        }
        if (button.count() == 0) {
            Assert.fail("Button not found ‚Äî ID: " + buttonId + " / text: " + buttonText);
        }
        System.out.println("‚úÖ Found button using: " + method);
        button.first().click();
    }

    /** Click nth button with specific text (with validation) */
    public static void clickNthButton(Page page, String buttonText, int index) {
        Locator buttons = page.locator("button, [role='button']")
            .filter(new Locator.FilterOptions().setHasText(buttonText));
        int count = buttons.count();
        System.out.println("üìä Found " + count + " '" + buttonText + "' button(s)");
        if (count == 0) Assert.fail("No '" + buttonText + "' buttons found");
        if (index >= count) Assert.fail("Requested index " + index + " but only " + count + " found");
        buttons.nth(index).click();
        System.out.println("‚úÖ Clicked '" + buttonText + "' button at index " + index);
    }

    /** Click first visible button with given text */
    public static void clickFirstVisibleButton(Page page, String buttonText) {
        Locator buttons = page.locator("button, [role='button']")
            .filter(new Locator.FilterOptions().setHasText(buttonText));
        Assert.assertTrue(buttons.count() > 0, "No '" + buttonText + "' button found");
        buttons.first().click();
    }

    /** Get count of buttons with given text */
    public static int getButtonCount(Page page, String buttonText) {
        return page.locator("button, [role='button']")
            .filter(new Locator.FilterOptions().setHasText(buttonText)).count();
    }

    /** Click button in the row containing the given row text */
    public static void clickButtonInRow(Page page, String rowText, String buttonText) {
        Locator row = page.locator("tr").filter(new Locator.FilterOptions().setHasText(rowText));
        Assert.assertTrue(row.count() > 0, "Row containing '" + rowText + "' not found");
        row.first().locator("button, [role='button']")
            .filter(new Locator.FilterOptions().setHasText(buttonText))
            .first().click();
    }

    /** Validate button exists (or not) */
    public static void validateButtonState(Page page, String buttonText, boolean shouldExist) {
        int count = getButtonCount(page, buttonText);
        if (shouldExist) Assert.assertTrue(count > 0, "Button '" + buttonText + "' should exist");
        else Assert.assertEquals(count, 0, "Button '" + buttonText + "' should NOT exist");
    }

    /** Click button with retry on failure */
    public static void clickButtonWithRetry(Page page, String buttonText, int maxRetries) {
        for (int i = 0; i < maxRetries; i++) {
            try {
                clickFirstVisibleButton(page, buttonText);
                return;
            } catch (Exception e) {
                if (i == maxRetries - 1) throw e;
                System.out.println("‚ö†Ô∏è Retry " + (i+1) + "/" + maxRetries + " for button: " + buttonText);
            }
        }
    }
}
```

---

## üìä Method Performance Summary

| Method | Performance | Reliability | Maintenance |
|--------|-------------|-------------|-------------|
| `clickButtonInContext()` | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| `clickButtonSmart()` | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| `clickButtonInRow()` | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| `clickFirstVisibleButton()` | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| `clickNthButton()` | ‚≠ê‚≠ê | ‚≠ê | ‚≠ê |

---

---

# üöÄ Part 4: NPM CLI & Migration Guide

> **Purpose:** Cross-platform CLI usage and migration from `.bat`/`.ps1` scripts to NPM.

---

## Overview

This framework uses a universal NPM-based CLI (`automation-cli.js`) for cross-platform compatibility. All `quick-start.bat` / `record-pw.ps1` commands have NPM equivalents.

---

## Command Reference

### Quick Reference Table

| Old Platform-Specific | New Cross-Platform (NPM) | Description |
|---|---|---|
| `quick-start.bat` | `npm start` | Interactive menu |
| `record-pw.ps1` | `npm run record` | Record & auto-generate |
| `quick-start.bat` Option 1B | `npm run retry` | Retry from recording |
| `quick-start.bat` Option 2 | `npm run jira` | Generate from JIRA story |
| `quick-start.bat` Option 3 | `npm run ai-generate` | AI interactive generation |
| `quick-start.bat` Option S | `npm run setup` | Setup MCP server |
| `quick-start.bat` Option I | `npm run install-deps` | Install dependencies |
| `quick-start.bat` Option C | `npm run clean` | Clean build artifacts |
| `quick-start.bat` Option T | `npm run help` | Tutorial/Help |
| `mvn clean test` | `npm test` | Run tests via Maven |

### Direct Node.js (Alternative)

```bash
node automation-cli.js             # Show menu
node automation-cli.js --option=1  # Record
node automation-cli.js --option=2  # Retry
node automation-cli.js --option=3  # JIRA
node automation-cli.js --option=4  # AI Interactive
node automation-cli.js --option=5  # Setup
node automation-cli.js --option=6  # Install
node automation-cli.js --option=7  # Clean
node automation-cli.js --option=8  # Help
```

---

## Why NPM?

| Before (Platform-Dependent) | After (Cross-Platform) |
|---|---|
| ‚ùå `quick-start.bat` ‚Äî Windows only | ‚úÖ `npm start` ‚Äî Windows, macOS, Linux |
| ‚ùå `record-pw.ps1` ‚Äî PowerShell only | ‚úÖ Single source: `automation-cli.js` |
| ‚ùå 3+ script files to maintain | ‚úÖ Professional, industry-standard |
| ‚ùå Not CI/CD friendly | ‚úÖ CI/CD ready |

---

## Setup Steps

### Step 1: Install NPM Dependencies

```bash
npm install
```

Installs: `chalk` (colors), `prompts` (interactive), `ora` (spinners), `commander` (CLI args).

### Step 2: Verify Commands

```bash
npm start        # Shows interactive menu ‚Äî press X to exit
npm run help     # Shows tutorial
npm run setup    # Installs MCP server (if not done)
```

### Step 3: Verify Test Generation

```bash
npm run record   # Record actions ‚Üí generates Page, Feature, Steps files
npm run retry    # Reuse existing recording
npm test         # Run Maven tests, reports to MRITestExecutionReports/
```

### Step 4: CI/CD Integration

```yaml
# .github/workflows/test.yml
steps:
  - uses: actions/setup-node@v3
  - run: npm install
  - run: npm test
```

### Custom NPM Scripts (package.json)

```json
{
  "scripts": {
    "test:smoke": "mvn test -Dcucumber.filter.tags=@smoke",
    "test:regression": "mvn test -Dcucumber.filter.tags=@regression"
  }
}
```

---

## Migration Checklist

- [ ] `npm install` runs without errors
- [ ] `npm start` shows interactive menu with all options
- [ ] `npm run record` opens Playwright Inspector
- [ ] Recording generates all 3 file types (Page, Feature, Steps)
- [ ] `npm test` runs Maven tests successfully
- [ ] Reports generate in `MRITestExecutionReports/`
- [ ] Updated CI/CD pipelines to use `npm install` + `npm test`
- [ ] Team onboarding docs updated

---

## Troubleshooting

### `npm: command not found`

```bash
# Windows: download from nodejs.org
# macOS:  brew install node
# Linux:  sudo apt install nodejs npm
```

### `npm install` fails with permission errors

```bash
# macOS/Linux
sudo chown -R $USER ~/.npm
# Windows: Run PowerShell as Administrator
```

### `npm run record` doesn't open browser

```bash
mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="install"
```

### Corporate proxy

```
# .npmrc
proxy=http://proxy.company.com:8080
https-proxy=http://proxy.company.com:8080
```

---

## Rollback Plan

If you need to revert to old `.bat`/`.ps1` scripts:

1. Keep old files (don't delete them yet)
2. Run `quick-start.bat` ‚Äî still works unchanged
3. To fully remove NPM: `rm package.json .npmrc package-lock.json && rm -rf node_modules/`
4. Revert CLI: `git checkout automation-cli.js`

---

**Status:** ‚úÖ Active ‚Äî All NPM commands tested and working on Windows, macOS, Linux  
**Last Validation Date:** February 26, 2026
